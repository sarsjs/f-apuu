Aqu铆 tienes los archivos del Backend (Python/Flask) listos para funcionar con la l贸gica de IA que definimos.

1. backend/app.py (El Servidor)
Este es el archivo que tu agente debe crear. Contiene:

Conexi贸n a Gemini: Configurada para recibir tu API Key.

Endpoint /api/ia/chat_apu: Recibe la descripci贸n de la obra, construye el prompt experto (con c谩lculo de cantidades) y devuelve el JSON para la tabla de An谩lisis.

Endpoint /api/ia/cotizar: Recibe un material y devuelve los 3 precios de mercado para el Comparador.
---------------------------------------------------------------------------------------------------------------------------
backend/app.py

import os
import json
from flask import Flask, request, jsonify
from flask_cors import CORS
import google.generativeai as genai

# --- CONFIGURACIN ---
app = Flask(__name__)
CORS(app)  # Permite que tu frontend (React) hable con este backend

# Configura tu API Key de Google Gemini aqu铆
# Opci贸n A: Desde variable de entorno (Recomendado)
# GEMINI_API_KEY = os.getenv("GEMINI_API_KEY")
# Opci贸n B: Directa (Solo para pruebas locales)
GEMINI_API_KEY = "TU_API_KEY_DE_GEMINI_AQUI" 

genai.configure(api_key=GEMINI_API_KEY)

# Configuraci贸n del modelo
generation_config = {
  "temperature": 0.7,
  "top_p": 0.95,
  "top_k": 64,
  "max_output_tokens": 8192,
  "response_mime_type": "application/json",
}

model = genai.GenerativeModel(
  model_name="gemini-1.5-flash", # Modelo r谩pido y econ贸mico
  generation_config=generation_config,
)

# --- PROMPTS DEL SISTEMA (Tus reglas de negocio) ---

SYSTEM_PROMPT_APU = """
Act煤a como un experto analista de costos de construcci贸n en M茅xico.
Genera una matriz de Precios Unitarios (APU) detallada.

REGLAS OBLIGATORIAS DE RESPUESTA (JSON):
1. "cantidad_obra_detectada": Si la descripci贸n incluye dimensiones (ej. "Muro 10x3", "Losa de 50m2"), calcula el total matem谩tico. Si no, devuelve null.
2. "unidad_obra_detectada": La unidad resultante (m2, m3, ml).
3. "tipo_documento": Clasifica si es "Presupuesto" (formal), "Nota de Venta" (simple) o "Factura".
4. "insumos": Lista de materiales/mano de obra.
   - "tipo_insumo": SOLO usa: "Material", "Mano de Obra", "Equipo", "Maquinaria".
   - "unidad": SOLO usa: "pza", "m2", "m3", "ml", "kg", "ton", "litro", "galon", "bulto", "caja", "lote", "jor", "hr", "dia".
   - "cantidad": Coeficiente t茅cnico para 1 unidad de obra (no el total).
   - "merma": Decimal (ej. 0.05 para 5%).
   - "precio_unitario": Inicializa siempre en 0 (el usuario lo cotiza despu茅s).

Tu respuesta debe ser EXCLUSIVAMENTE el objeto JSON.
"""

SYSTEM_PROMPT_COTIZADOR = """
Act煤a como un experto en compras de materiales de construcci贸n en M茅xico.
El usuario te dar谩 un nombre de material. Tu misi贸n es estimar 3 precios de mercado realistas (Bajo, Promedio, Alto).
Devuelve un JSON con esta estructura exacta:
{
  "tienda1": "Nombre Tienda Gen茅rica A", "precio1": 100.00,
  "tienda2": "Nombre Tienda Gen茅rica B", "precio2": 95.00,
  "tienda3": "Nombre Tienda Gen茅rica C", "precio3": 110.00
}
"""

# --- ENDPOINTS (Rutas) ---

@app.route('/api/ia/chat_apu', methods=['POST'])
def generar_apu():
    try:
        data = request.json
        descripcion = data.get('descripcion', '')
        
        if not descripcion:
            return jsonify({"error": "Falta descripci贸n"}), 400

        # Construir el prompt final
        prompt = f"{SYSTEM_PROMPT_APU}\n\nCONCEPTO A ANALIZAR: {descripcion}"
        
        # Llamar a Gemini
        response = model.generate_content(prompt)
        
        # Parsear respuesta (Gemini devuelve JSON string)
        resultado_json = json.loads(response.text)
        
        return jsonify(resultado_json)

    except Exception as e:
        print(f"Error en IA: {e}")
        return jsonify({
            "explicacion": "Hubo un error al conectar con la IA. Intenta de nuevo.",
            "insumos": []
        }), 500

@app.route('/api/ia/cotizar', methods=['POST'])
def cotizar_material():
    try:
        data = request.json
        material = data.get('material', '')
        
        if not material:
            return jsonify({"error": "Falta material"}), 400

        prompt = f"{SYSTEM_PROMPT_COTIZADOR}\n\nMATERIAL A COTIZAR: {material}"
        
        response = model.generate_content(prompt)
        resultado_json = json.loads(response.text)
        
        return jsonify(resultado_json)

    except Exception as e:
        print(f"Error cotizando: {e}")
        return jsonify({
            "tienda1": "Error IA", "precio1": 0,
            "tienda2": "-", "precio2": 0,
            "tienda3": "-", "precio3": 0
        }), 500

# --- INICIO DEL SERVIDOR ---
if __name__ == '__main__':
    print(" Servidor Backend APU Builder corriendo en http://localhost:8000")
    app.run(port=8000, debug=True)
--------------------------------------------------------------------------------------------------------------------------------------------
2. backend/requirements.txt
Tu agente necesitar谩 instalar estas librer铆as para que el c贸digo de arriba funcione.
--------------------------------------------------------------------------------------------------------------------------------------
backend/requirements.txt

flask
flask-cors
google-generativeai
------------------------------------------------------------------------------------------------------------------------------------------------
3. Actualizaci贸n Final: AnalisisPuPage.tsx con Fetch Real
Ahora que tenemos el backend, actualizamos el Frontend para que deje de usar el setTimeout (simulaci贸n) y llame de verdad a http://localhost:8000/api/ia/chat_apu.

Pasos para tu Agente:

Crear la carpeta backend y dentro app.py y requirements.txt.

Reemplazar el contenido de AnalisisPuPage.tsx con este 煤ltimo bloque de c贸digo.

Instalar dependencias (pip install -r backend/requirements.txt).

Correr el servidor (python backend/app.py).

隆Y listo! Tendr谩s tu sistema APU Builder totalmente funcional y con inteligencia real.
